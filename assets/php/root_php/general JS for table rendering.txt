/**
 * Generic Table Management System
 * Handles multiple tables with sorting, pagination, and inline editing
 
 this shall go to root.js and the initial functions in each file related for it
  ex [products.php initilize table (products_table_ID, configs);]
 */

// Configuration object to store settings for each table
const tableConfig = {};

// Initialize tables when the page loads
document.addEventListener('DOMContentLoaded', function() {
    // Initialize each table you want to manage
    initTable('transactions-table', {
        idField: 'Payment_ID',
        defaultSort: 'Payment_ID',
        defaultSortDirection: 'asc',
        defaultRowsPerPage: 100,
        editableFields: ['Payment_Method', 'Payment_Status', 'Amount'],
        sampleData: [{
            Payment_ID: 1,
            Order_ID: 3,
            User_ID: 2,
            Username: "Afnan_3xx",
            Payment_Method: "credit card",
            Payment_Status: "Complete",
            Transaction_ID: 12,
            Amount: 12.75,
            Created_At: "2025-02-27"
        }]
    });

    // Example: Initialize another table
    initTable('orders-table', {
        idField: 'Order_ID',
        defaultSort: 'Order_ID',
        defaultSortDirection: 'asc',
        defaultRowsPerPage: 50,
        editableFields: ['Status', 'Total'],
        sampleData: [{
            Order_ID: 3,
            User_ID: 2,
            Status: "Shipped",
            Total: 12.75,
            Items: 2,
            Created_At: "2025-02-27"
        }]
    });
    
    // Add more tables as needed
});

/**
 * Initialize a table with the given configuration
 * @param {string} tableId - The base ID for the table (used to find elements)
 * @param {object} config - Configuration options for the table
 */
function initTable(tableId, config) {
    // Store configuration
    tableConfig[tableId] = {
        data: [...config.sampleData],
        currentPage: 1,
        rowsPerPage: config.defaultRowsPerPage || 100,
        sortColumn: config.defaultSort || config.idField,
        sortDirection: config.defaultSortDirection || 'asc',
        editingRow: null,
        rowToDelete: null,
        idField: config.idField,
        editableFields: config.editableFields || [],
        numericFields: config.numericFields || ['Amount', 'Total', 'Price', 'Stock']
    };
    
    // Load data and set up event listeners
    loadTableData(tableId);
    setupSortingListeners(tableId);
    setupPaginationListeners(tableId);
    
    // Set default rows per page in the dropdown
    const rowsPerPageSelect = document.getElementById(`${tableId}_rows_per_page`);
    if (rowsPerPageSelect) {
        rowsPerPageSelect.value = tableConfig[tableId].rowsPerPage;
    }
}

/**
 * Fetch data for a specific table (simulated)
 * @param {string} tableId - The table identifier
 * @returns {Promise<Array>} - The data for the table
 */
async function fetchTableData(tableId) {
    // In a real implementation, you would fetch from an API with tableId as parameter
    // For now, we'll return the sample data
    
    // Simulate API delay
    await new Promise(resolve => setTimeout(resolve, 300));
    
    return [...tableConfig[tableId].data];
}

/**
 * Load data into a specific table
 * @param {string} tableId - The table identifier
 */
async function loadTableData(tableId) {
    // In a real implementation, you would fetch data here
    // tableConfig[tableId].data = await fetchTableData(tableId);
    
    renderTable(tableId);
    updatePaginationInfo(tableId);
}

/**
 * Render a specific table with current data and settings
 * @param {string} tableId - The table identifier
 */
function renderTable(tableId) {
    const config = tableConfig[tableId];
    const tableBody = document.getElementById(`${tableId}-body`);
    
    if (!tableBody) {
        console.error(`Table body element not found for ${tableId}`);
        return;
    }
    
    tableBody.innerHTML = '';
    
    // Sort data
    const sortedData = [...config.data].sort((a, b) => {
        let valA = a[config.sortColumn];
        let valB = b[config.sortColumn];
        
        // Handle numeric sorts
        if (config.numericFields.includes(config.sortColumn)) {
            valA = parseFloat(valA);
            valB = parseFloat(valB);
        }
        
        if (config.sortDirection === 'asc') {
            return valA > valB ? 1 : -1;
        } else {
            return valA < valB ? 1 : -1;
        }
    });
    
    // Calculate pagination
    const startIndex = (config.currentPage - 1) * config.rowsPerPage;
    const endIndex = Math.min(startIndex + config.rowsPerPage, sortedData.length);
    const paginatedData = sortedData.slice(startIndex, endIndex);
    
    // Create table rows
    paginatedData.forEach(item => {
        const row = document.createElement('tr');
        row.setAttribute('data-id', item[config.idField]);
        
        // Get all fields from the first item to determine columns
        const fields = Object.keys(item);
        
        // Create cells for each field
        fields.forEach(field => {
            const cell = document.createElement('td');
            
            // Check if this field is editable
            if (config.editableFields.includes(field)) {
                cell.classList.add('editable-cell');
                cell.setAttribute('data-field', field);
            }
            
            cell.textContent = item[field];
            row.appendChild(cell);
        });
        
        // Add action buttons
        const actionsCell = document.createElement('td');
        const itemId = item[config.idField];
        
        actionsCell.innerHTML = `
            <div class="buttons_table" id="${tableId}_buttons_${itemId}">
                <button type="button" class="edit_button_style" onclick="editItem('${tableId}', ${itemId})">Edit</button>
                <button type="button" class="remove_button_style" onclick="confirmDelete('${tableId}', ${itemId})">Remove</button>
            </div>
            <div class="buttons_table" id="${tableId}_edit_buttons_${itemId}" style="display:none;">
                <button type="button" class="cancel_edit_style" onclick="cancelEdit('${tableId}', ${itemId})">Cancel</button>
                <button type="button" class="confirm_edit_style" onclick="saveEdit('${tableId}', ${itemId})">Save</button>
            </div>
        `;
        
        row.appendChild(actionsCell);
        tableBody.appendChild(row);
    });
    
    // Update sorting indicators
    updateSortIndicators(tableId);
}

/**
 * Set up column sorting for a specific table
 * @param {string} tableId - The table identifier
 */
function setupSortingListeners(tableId) {
    const headers = document.querySelectorAll(`#${tableId}-head th[data-sort]`);
    
    headers.forEach(header => {
        header.addEventListener('click', () => {
            const column = header.getAttribute('data-sort');
            const config = tableConfig[tableId];
            
            // If clicking the same column, toggle direction
            if (config.sortColumn === column) {
                config.sortDirection = config.sortDirection === 'asc' ? 'desc' : 'asc';
            } else {
                config.sortColumn = column;
                config.sortDirection = 'asc';
            }
            
            renderTable(tableId);
        });
    });
}

/**
 * Update sort indicators for a specific table
 * @param {string} tableId - The table identifier
 */
function updateSortIndicators(tableId) {
    const headers = document.querySelectorAll(`#${tableId}-head th[data-sort]`);
    const config = tableConfig[tableId];
    
    headers.forEach(header => {
        const column = header.getAttribute('data-sort');
        const sortIcon = header.querySelector('.sort-icon');
        
        if (sortIcon) {
            if (column === config.sortColumn) {
                sortIcon.textContent = config.sortDirection === 'asc' ? '↑' : '↓';
            } else {
                sortIcon.textContent = '↕';
            }
        }
    });
}

/**
 * Set up pagination controls for a specific table
 * @param {string} tableId - The table identifier
 */
function setupPaginationListeners(tableId) {
    const prevButton = document.getElementById(`${tableId}_prev-page`);
    const nextButton = document.getElementById(`${tableId}_next-page`);
    
    if (prevButton) {
        prevButton.addEventListener('click', () => {
            const config = tableConfig[tableId];
            if (config.currentPage > 1) {
                config.currentPage--;
                renderTable(tableId);
                updatePaginationInfo(tableId);
            }
        });
    }
    
    if (nextButton) {
        nextButton.addEventListener('click', () => {
            const config = tableConfig[tableId];
            const maxPage = Math.ceil(config.data.length / config.rowsPerPage);
            if (config.currentPage < maxPage) {
                config.currentPage++;
                renderTable(tableId);
                updatePaginationInfo(tableId);
            }
        });
    }
}

/**
 * Update pagination information for a specific table
 * @param {string} tableId - The table identifier
 */
function updatePaginationInfo(tableId) {
    const config = tableConfig[tableId];
    const totalItems = config.data.length;
    const startItem = Math.min((config.currentPage - 1) * config.rowsPerPage + 1, totalItems);
    const endItem = Math.min(startItem + config.rowsPerPage - 1, totalItems);
    
    const startElement = document.getElementById(`${tableId}_showing-start`);
    const endElement = document.getElementById(`${tableId}_showing-end`);
    const totalElement = document.getElementById(`${tableId}_total-items`);
    const prevButton = document.getElementById(`${tableId}_prev-page`);
    const nextButton = document.getElementById(`${tableId}_next-page`);
    
    if (startElement) startElement.textContent = startItem;
    if (endElement) endElement.textContent = endItem;
    if (totalElement) totalElement.textContent = totalItems;
    
    // Enable/disable pagination buttons
    if (prevButton) prevButton.disabled = (config.currentPage === 1);
    if (nextButton) nextButton.disabled = (endItem === totalItems);
}

/**
 * Change rows per page for a specific table
 * @param {string} tableId - The table identifier
 */
function changeRowsPerPage(tableId) {
    const select = document.getElementById(`${tableId}_rows_per_page`);
    if (select) {
        tableConfig[tableId].rowsPerPage = parseInt(select.value);
        tableConfig[tableId].currentPage = 1; // Reset to first page
        renderTable(tableId);
        updatePaginationInfo(tableId);
    }
}

/**
 * Edit an item in a specific table
 * @param {string} tableId - The table identifier
 * @param {number|string} itemId - The ID of the item to edit
 */
function editItem(tableId, itemId) {
    const config = tableConfig[tableId];
    
    // Save the current editing row
    config.editingRow = itemId;
    
    // Show edit buttons and hide regular buttons
    document.getElementById(`${tableId}_buttons_${itemId}`).style.display = 'none';
    document.getElementById(`${tableId}_edit_buttons_${itemId}`).style.display = 'flex';
    
    // Make fields editable
    const row = document.querySelector(`#${tableId}-body tr[data-id="${itemId}"]`);
    const editableCells = row.querySelectorAll('.editable-cell');
    
    editableCells.forEach(cell => {
        const field = cell.getAttribute('data-field');
        const value = cell.textContent;
        
        // Replace with input field
        cell.innerHTML = `<input type="text" name="${field}" value="${value}" />`;
        cell.classList.add('editable');
    });
}

/**
 * Cancel editing an item in a specific table
 * @param {string} tableId - The table identifier
 * @param {number|string} itemId - The ID of the item being edited
 */
function cancelEdit(tableId, itemId) {
    const config = tableConfig[tableId];
    const idField = config.idField;
    
    // Get item data
    const item = config.data.find(i => i[idField] === itemId);
    
    // Reset the row
    const row = document.querySelector(`#${tableId}-body tr[data-id="${itemId}"]`);
    const editableCells = row.querySelectorAll('.editable-cell');
    
    editableCells.forEach(cell => {
        const field = cell.getAttribute('data-field');
        cell.innerHTML = item[field];
        cell.classList.remove('editable');
    });
    
    // Show regular buttons and hide edit buttons
    document.getElementById(`${tableId}_buttons_${itemId}`).style.display = 'flex';
    document.getElementById(`${tableId}_edit_buttons_${itemId}`).style.display = 'none';
    
    // Clear editing state
    config.editingRow = null;
}

/**
 * Save edits to an item in a specific table
 * @param {string} tableId - The table identifier
 * @param {number|string} itemId - The ID of the item being edited
 */
function saveEdit(tableId, itemId) {
    const config = tableConfig[tableId];
    const idField = config.idField;
    
    // Get the row
    const row = document.querySelector(`#${tableId}-body tr[data-id="${itemId}"]`);
    const editableCells = row.querySelectorAll('.editable-cell');
    
    // Find the item to update
    const itemIndex = config.data.findIndex(i => i[idField] === itemId);
    
    if (itemIndex !== -1) {
        // Update item with new values
        editableCells.forEach(cell => {
            const field = cell.getAttribute('data-field');
            const input = cell.querySelector('input');
            const value = input.value;
            
            // Update item data
            if (config.numericFields.includes(field)) {
                config.data[itemIndex][field] = parseFloat(value);
            } else {
                config.data[itemIndex][field] = value;
            }
            
            // Update cell content
            cell.innerHTML = value;
            cell.classList.remove('editable');
        });
        
        // Update timestamp if the table has an updated_date field
        if ('updated_date' in config.data[itemIndex]) {
            config.data[itemIndex].updated_date = new Date().toISOString().slice(0, 10);
            
            // Find and update the cell for updated_date
            const updatedDateCell = Array.from(row.cells).find(cell => 
                cell.getAttribute('data-field') === 'updated_date'
            );
            
            if (updatedDateCell) {
                updatedDateCell.textContent = config.data[itemIndex].updated_date;
            }
        }
        
        // In a real implementation, you would send the updates to the server here
        
        // Show success message or notification
        console.log(`Item updated in ${tableId}:`, config.data[itemIndex]);
    }
    
    // Show regular buttons and hide edit buttons
    document.getElementById(`${tableId}_buttons_${itemId}`).style.display = 'flex';
    document.getElementById(`${tableId}_edit_buttons_${itemId}`).style.display = 'none';
    
    // Clear editing state
    config.editingRow = null;
}

/**
 * Display confirmation before deleting an item
 * @param {string} tableId - The table identifier
 * @param {number|string} itemId - The ID of the item to delete
 */
function confirmDelete(tableId, itemId) {
    // Store the item to delete
    tableConfig[tableId].rowToDelete = itemId;
    
    // Show confirmation dialog or modal
    // This could be done using a modal element with ID like `${tableId}_delete_modal`
    const confirmed = confirm(`Are you sure you want to delete this item from ${tableId}?`);
    
    if (confirmed) {
        deleteItem(tableId, itemId);
    } else {
        tableConfig[tableId].rowToDelete = null;
    }
}

/**
 * Delete an item from a specific table
 * @param {string} tableId - The table identifier
 * @param {number|string} itemId - The ID of the item to delete
 */
function deleteItem(tableId, itemId) {
    const config = tableConfig[tableId];
    const idField = config.idField;
    
    // Remove the item from the data array
    const itemIndex = config.data.findIndex(i => i[idField] === itemId);
    
    if (itemIndex !== -1) {
        config.data.splice(itemIndex, 1);
        
        // In a real implementation, you would send a delete request to the server here
        
        // Refresh the table
        renderTable(tableId);
        updatePaginationInfo(tableId);
        
        // Show success message or notification
        console.log(`Item deleted from ${tableId}: ${itemId}`);
    }
    
    // Clear delete state
    config.rowToDelete = null;
}

/**
 * Add a new item to a specific table
 * @param {string} tableId - The table identifier
 * @param {object} itemData - The data for the new item
 */
function addItem(tableId, itemData) {
    const config = tableConfig[tableId];
    
    // Add the new item to the data array
    config.data.push(itemData);
    
    // In a real implementation, you would send a create request to the server here
    
    // Refresh the table
    renderTable(tableId);
    updatePaginationInfo(tableId);
    
    // Show success message or notification
    console.log(`Item added to ${tableId}:`, itemData);
}

/**
 * Filter items in a specific table
 * @param {string} tableId - The table identifier
 * @param {function} filterFn - The filter function to apply
 */
function filterTable(tableId, filterFn) {
    // This is a simplified implementation
    // In a real application, you might want to store the original data
    // and apply filters to a copy
    
    const originalData = tableConfig[tableId].data;
    tableConfig[tableId].filteredData = originalData.filter(filterFn);
    tableConfig[tableId].currentPage = 1; // Reset to first page
    
    renderTable(tableId);
    updatePaginationInfo(tableId);
}

/**
 * Search for items in a specific table
 * @param {string} tableId - The table identifier
 * @param {string} searchTerm - The term to search for
 * @param {Array} searchFields - The fields to search in
 */
function searchTable(tableId, searchTerm, searchFields) {
    if (!searchTerm) {
        // If search term is empty, restore original data
        tableConfig[tableId].filteredData = null;
    } else {
        // Filter data based on search term
        const term = searchTerm.toLowerCase();
        filterTable(tableId, item => {
            return searchFields.some(field => {
                const value = String(item[field]).toLowerCase();
                return value.includes(term);
            });
        });
    }
}